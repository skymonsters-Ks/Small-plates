;$a>ax_fpssnd.ax

#include "hsp3dish.as"
#include "../common/font.hsp"

; frame/sec
#const global  C_FPS 60
; msec/frame
#const global  C_MSPF 1000.0 / C_FPS

#const global ARROW_MAX 2000

#const TEST1_FRAME  1000
#const TEST2_FRAME  300

#const PI_D2     M_PI / 2
#const PI_D4     M_PI / 4
#const PI2_DFPS  M_PI * 2 / C_FPS

#enum RES_UFRAME = 0
#enum RES_DFRAME
#enum RES_FPS
#enum RES_NUM

	// sounds: http://www.senses-circuit.com/
	mmload "loop_101.ogg",   0, 1 : mmvol 0, -500
	mmload "loop_88.ogg",    1, 1 : mmvol 1, -500
	mmload "se_game_08.ogg", 2, 0 : mmvol 2, -500
	mmload "se_game_42.ogg", 3, 0
	mmload "se_game_32.ogg", 4, 0
		repeat 4 : mmvol 10 + cnt, -600 : mmpan 10 + cnt, ((cnt \ 2) * 2 - 1) * 800 : loop
	mmload "se_game_34.ogg", 5, 0
	mmload "se_game_35.ogg", 6, 0
	initFont
	loadFont "f_recp8x8.png"
	initArrow
	teststr = "FRAME TEST", "STRESS TEST", "RESULT"
	gosub *init

*mainLoop
	gosub *control
	manageFrame 1
	ucnt = stat
	timer fps
	ntime = stat
	frame_timer = int(double(ntime) / C_MSPF)
	if (ucnt) {
		repeat ucnt
			gosub *update
			frame_update++
		loop
		gosub *draw
		frame_draw++
	}
	await 1
	goto *mainLoop

*init
	initFrame
	initActor
	repeat 50
		addActor
	loop
	frame_timer = 0
	frame_update = 0
	frame_draw = 0
	fps = 0.0
	fpsm = 0.0
	dim res, 4
	mode = 0
	stopcnt = 0
	mmstop
	mmplay 0
	mmplay 2
	return

*control
	stick k
	if (k & 256) {
		gosub *init
	}
	return

*update
	switch mode
	case 0
		if ((res == 0) && (frame_timer >= TEST1_FRAME)) {
			res(RES_UFRAME) = frame_update
			res(RES_DFRAME) = frame_draw
			res(RES_FPS) = int(fpsm)
			mode = 1
			initActor 1
			mmstop
			mmplay 1
		} else {
			if (fpsm < fps) {
				fpsm = fps
			}
		}
		swbreak
	case 1
		if ((fps < 55) || (cnum@actor == ARROW_MAX)) {
			stopcnt++
			if (stopcnt >= TEST2_FRAME) {
				res(RES_NUM) = cnum@actor
				mode = 2
				initActor 1
				mmstop
				mmplay 3
			}
		} else {
			if ((frame_update \ 3) == 0) {
				addActor
				mmplay 4, 10 + se4ch
				se4ch++ : se4ch \= 4
				if ((cnum@actor \ 100) == 0) {
					mmplay rnd(2) + 5
				}
				stopcnt = 0
			}
		}
	swend
	updateActor
	return

*draw
	redraw 0
	c = (mode > 0) * 240
	color c, c, c
	boxf
	drawActor
	c = (mode == 0) * 255
	color c, c, c
	drawMeter 25, double(frame_timer) / TEST1_FRAME, 4
	drawMeter 34, double(frame_draw) / TEST1_FRAME, 2
	drawMeter 41, double(stopcnt) / TEST2_FRAME, 2
	switch mode
	case 0
		strs(0) = str(frame_update)
		strs(1) = str(frame_draw)
		strs(2) = strf("%d/%d", fpsm, fps)
		strs(3) = ""
		swbreak
	case 1
		strs(0) = str(res(RES_UFRAME)), str(res(RES_DFRAME)), str(res(RES_FPS))
		strs(3) = strf("%d/%d", cnum@actor, fps)
		swbreak
	case 2
		strs = str(res(RES_UFRAME)), str(res(RES_DFRAME)), str(res(RES_FPS)), str(res(RES_NUM))
	swend
	gmode 3, , , 255
	if (mode) {
		gmulcolor 0, 0, 0
	} else {
		gmulcolor
	}
	setStrAttr 1, 1, 3
	drawStr teststr(mode), 10, 6
	setStrAttr 2, 2, 4
	drawStr strs(0), 10, 55
	drawStr strs(1), 10, 80
	drawStr strs(2), 10, 105
	drawStr strs(3), 10, 130
	redraw 1
	return

#deffunc drawMeter int _y, double _p, int _h
	line 640, _y, 0, _y
	boxf 0, _y - _h, _p * 640, _y + _h
	return


#module actor

#deffunc initActor int _m
	mode = _m
	max = ARROW_MAX
	cnum = 0
	ddim px, max
	ddim py, max
	ddim vx, max
	ddim vy, max
	ddim sz, max
	dim col, max
	return
	
#deffunc resetActor int _id
	sz(_id) = 0.1 * rnd(1000) + 20
	if (mode) {
		px(_id) = 0.1 * rnd(6400)
		py(_id) = 0.1 * rnd(4800)
		vx(_id) = 0.1 * (rnd(80) + 1) * (rnd(2) * 2 - 1)
		vy(_id) = 0.1 * (rnd(80) + 1) * (rnd(2) * 2 - 1)
		col(_id) = rnd(192)
	} else {
		px(_id) = 0.0 - sz(_id)
		py(_id) = 0.1 * rnd(4800)
		vx(_id) = sz(_id) / 8
	}
	return

#deffunc addActor
	if (cnum < max) {
		resetActor cnum
		cnum++
	}
	return

#deffunc updateActor
	repeat cnum
		px(cnt) += vx(cnt)
		py(cnt) += vy(cnt)
		if (mode) {
			if (px(cnt) < 0) {
				px(cnt) = -px(cnt)
				vx(cnt) *= -1
			}
			if (px(cnt) > 640) {
				px(cnt) = 1280.0 - px(cnt)
				vx(cnt) *= -1
			}
			if (py(cnt) < 0) {
				py(cnt) = -py(cnt)
				vy(cnt) *= -1
			}
			if (py(cnt) > 480) {
				py(cnt) = 960.0 - py(cnt)
				vy(cnt) *= -1
			}
		} else {
			if (px(cnt) > 640 + sz(cnt)) {
				resetActor cnt
			}
		}
	loop
	return

#deffunc drawActor
	repeat cnum
		if (mode) {
			a = 15
			d = atan(vy(cnt), vx(cnt))
			hsvcolor col(cnt), 200, 255
		} else {
			a = sz(cnt) / 2 + 20
			d = 0
			color 255, 255, 255
		}
		gmode 3, , , a
		drawArrow px(cnt), py(cnt), d, sz(cnt)
	loop
	return

#global 


#module 

#deffunc initArrow
	bx = -1.0, 0.0, 1.0, 0.0,  0.0, 1.0, 0.0, -1.0
	by =  1.0, 1.0, 0.0, 0.0,  0.0, 0.0, -1.0, -1.0
	return

#deffunc drawArrow int _x, int _y, double _r, double _s
	s = _s / 2
	repeat 2
		drawPoly cnt * 4, bx, by, _x, _y, _r, s
	loop
	return

#global 


#module 

#deffunc vecRot var _ox, var _oy, double _ix, double _iy, double _r
	_ox = _ix * cos(_r) - _iy * sin(_r)
	_oy = _ix * sin(_r) + _iy * cos(_r)
	return

#deffunc drawPoly int _i, array _vx, array _vy, int _x, int _y, double _r, double _s
	repeat 4
		vecRot rx, ry, _vx(_i + cnt), _vy(_i + cnt), _r
		x(cnt) = 0 + (_s * rx + _x)
		y(cnt) = 0 + (_s * ry + _y)
	loop
	gsquare -1, x, y
	return

#global 


#module frame

#deffunc initFrame
	count = 0
	delay = 0
	dim pt, 16
	getreq stime, SYSREQ_TIMER
	return

#deffunc manageFrame int _mode, local _res
	_res = 0
	getreq time, SYSREQ_TIMER
	dt = (time - stime) - C_MSPF * count
	if (dt >= 0) {
		_res = 1
		count++
		dc = dt / C_MSPF
		if (dc > 0) {
			delay += dc
			count += dc
			if (_mode) {
				_res += dc
			}
		}
	}
	return _res

#deffunc timer var _fps, int _id
	getreq t, SYSREQ_TIMER
	tdt(_id) += t - pt(_id)
	pt(_id) = t
	fc(_id)++
	if (tdt(_id) >= 250) {
		_fps = double(fc(_id)) / tdt(_id) * 1000
		fc(_id) = 0
		tdt(_id) = 0
	}
	return t - stime

#global 
